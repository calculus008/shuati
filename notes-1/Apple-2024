# Plan
Collect all Apple problems (last 6 months)
Problem Categories deep dive:
  Search (DFS, BFS)       done
  Sliding Window          done
  Stack                   done
  Intervals               done
  Prefix Sum              done
  Trie                    done

  Tree (BT and BST)              done
  Graph
  Big Data
  Design
  TreeMap

Java Multi-thread



Level of proficiency:
***** can write bug free code and analyse complexity
****  can tell algo and key steps
***   can tell the overall algo
**    can look at code and understand the algo



# Last 6 Months
LE_01_Two_Sum                     (HashMap)
LE_02_Add_Two_Numbers             (Linked List)
LE_03_Longest_Substring_Without_Repeating_Characters (Sliding Window)
LE_04_Median_Of_Two_Sorted_Arrays (Binary Search)                            ***
LE_07_Reverse_Integer
LE_11_Container_With_Most_Water   (Two Pointers)
LE_14_Longest_Common_Prefix       (Trie)
LE_15_3Sum                        (Two Pointers)
LE_20_Valid_Parentheses           (Stack)
LE_21_Merge_Two_Sorted_Lists      (Linked List, recursive and iterative)
LE_22_Generate_Parentheses        (Recursion, Backtracking)
LE_23_Merge_k_Sorted_Lists        (Heap)                                     *****
LE_26_Remove_Dup_From_Sorted_Array
LE_28_Implementing_Strstr         ###
LE_29_Divide_Two_Integers         ###
LE_33_Search_In_Rotated_Sorted_Array (Binary Search)
LE_34_Search_For_A_Range          (Binary Search)                           *****
LE_35_Search_For_Insertion_Point  (Binary Search)
LE_36_Valid_Sudoku                (Matrix, 2D Array)
LE_39_Combination_Sum             (DFS, Backtracking)
LE_42_Trapping_Rain_Water         (Two Pointers)                             ***
LE_44_Wildcards_Matching          (Backtracking)                             ###
LE_46_Permutation                 (DFS, Backtracking)
LE_48_Rotate_Image                (Matrix, 2D Array)
LE_49_Group_Anagrams              (HashMap + Sorting)
LE_54_Spiral_Matrix               (Matrix)
LE_55_Jump_Game                   (Greedy)
LE_56_Merge_Intervals             (Intervals)
LE_57_Insert_Interval             (Intervals)
LE_61_Rotate_List                 (Linked List)
LE_67_Add_Binary                  (Two Pointers)
LE_69_Sqrt                        (Binary Search)
LE_70_Climbing_Stairs             (Recursion + Mem)
LE_71_Simplify_Path               (Stack)
LE_73_Set_Matrix_Zero             (Matrix)
LE_79_Word_Search                 (DFS)
LE_88_Merge_Sorted_Array          (Array + Two Pointers)
LE_90_Subsets_II                  (Backtracking)
LE_92_Reverse_LinkedList_II       (Linked List)
LE_101_Symmetric_Tree             (Tree)
LE_102_Binary_Tree_Level_Order_Traversal     (Tree, BFS, pre-order DFS)
LE_104_Max_Depth_Of_Binary_Tree   (Tree)
LE_153_Find_Min_In_Rotated_Sorted_Array   (Binary Search)
LE_151_Reverse_Words_In_A_String  (String)
LE_155_Min_Stack                  (Stack)
LE_165_Compare_Version_Number     (String)
LE_169_Majority_Element           (Array)
LE_1275_Find_Winner_On_A_Tic_Tac_Toe_Game                        (Matrix)
LE_1963_Minimum_Number_Of_Swaps_To_Make_The_String_Balanced      (Two Pointers or Two Counters)

# Fast go-over
LE_118_Pascal_Triangle
LE_146_LRU_Cache                  (Design, Double-LinkedList + HashMap)
LE_167_Two_Sum_II_Array_Is_Sorted (Two Pointers)
LE_189_Rotate_Array               (String, Swap)
LE_190_Reverse_Bits               (Bit)
LE_191_Number_Of_1_Bits           (Bit)
LE_200_Number_Of_Islands
LE_202_Happy_Number               (Math, HastSet)
LE_207_Course_Schedule            (Topological Sort)
LE_208_Implement_Trie             (Trie)
LE_215_Kth_Largest_Element_In_Array   (PriorityQueue, Counting Sort, Quick Sort)
LE_232_Implement_Queue_Using_Stacks   (Stack)
LE_235_Lowest_Common_Ancestor_Of_BST  (Tree)
LE_236_Lowest_Common_Ancestor_Of_BT   (Tree)
LE_237_Delete_Node_In_Linked_List     (LinkedList)
LE_238_Product_Of_Array_Except_Self   (Array, Prefix Multiplication)
LE_240_Search_2D_Matrix_II        (Two Pointers in 2D arrays)
LE_242_Valid_Anagram              (Array, HashTable/CharArray count)
LE_252_Meeting_Rooms              (Intervals(MeetingRoom))
LE_253_Meeting_Rooms_II           (Intervals(MeetingRoom))
LE_274_H_Index                    (Counting Sort)
LE_283_Move_Zeroes                (Array)
LE_284_Peeking_Iterator           (Iterator)
LE_290_Word_Pattern               (HashMap)
LE_295_Find_Median_From_Data_Stream   (Heap,PriorityQueue)
LE_325_Maximum_Size_Subarray_Sum_Equals_k          (PrefixSum, HashMap)     ***          @@@
LE_339_Nested_List_Weight_Sum     (DFS, BFS)
LE_362_Design_Hit_Counter         (Design)
LE_394_Decode_String              (Queue + Recursion)                        ***
LE_412_Fizz_Buzz
LE_424_Longest_Repeating_Character_Replacement    (Sliding Window)           ***          @@@
LE_437_Path_Sum_III               (Tree, Prefix Sum, Backtracking)           ***
LE_443_String_Compression         (String, Two Pointers)
LE_448_Find_All_Numbers_Disappeared_In_An_Array                             (String)
LE_452_Minimum_Number_Of_Arrows_To_Burst_Balloons                           (Interval)
LE_509_Fibonacci_Number
LE_528_Random_Pick_With_Weight    (Prefix Sum + Binary Search)              *****
LE_532_K_Diff_Pairs_In_An_Array   (HashMap, Sort + Two Pointers)
LE_540_Single_Element_In_A_Sorted_Array       (Binary Search)
LE_560_Subarray_Sum_Equals_K      (Prefix Sum + HashMap)                     ***
LE_565_Array_Nesting              (DFS, Array)                               ***         @@@
LE_621_Task_Scheduler             (Priority Queue)                           ### ***
LE_628_Maximum_Product_Of_Three_Numbers       (Array)
LE_680_Valid_Palindrome_II        (Two Pointers)
LE_706_Design_HashMap             (Design)
LE_713_Subarray_Product_Less_Than_K                                        (Sliding Window)
LE_735_Asteroid_Collision         (Stack)                                  ****
LE_771_Jewels_And_Stones          (HashMap)
LE_846_Hand_Of_Straights          (TreeMap, PriorityQueue)                 3 different solutions, need to come back later ***
LE_867_Transpose_Matrix           (Matrix)
LE_953_Verifying_An_Alien_Dictionary                                       (String, Comparison)
LE_994_Rotting_Oranges            (BFS)
LE_1344_Angle_Between_Hands_Of_A_Clock
LE_1552_Magnetic_Force_Between_Two_Balls                                   (Binary Search with canDo())
LE_1657_Determine_If_Two_Strings_Are_Close                                 (HashMap, Set, Frequency)
LE_1768_Merge_Strings_Alternately                                          (String)
LE_2023_Number_Of_Pairs_Of_Strings_With_Concatenation_Equal_To_Target      (HashMap + string partition)
LE_2397_Maximum_Rows_Covered_By_Columns                                    (Recursion, Backtracking)         *****  @@@
leetcode.LE_2625_Flatten_Deeply_Nested_Array (BFS)                                                                           @@@
LE_2958_Length_Of_Longest_Subarray_With_At_Most_K_Frequency                (Sliding Window)
LE_2970_Count_The_Number_Of_Incremovable_Subarrays_I                       (Array)
LE_3040_Maximum_Number_Of_Operations_With_The_Same_Score_II

==================
# DP (Done)
LE_05_Longest_Palindromic_Substring                             *** very important
LE_53_Maximum_Subarray
LE_85_Maximal_Rectangle        Hard, can use histogram calculation to simplify ###
LE_91_Decode_Ways              ******* very important!
LE_97_Interleaving_String
LE_118_Pascal_Triangle
LE_120_Triangle
LE_198_House_Robber
LE_213_House_Robber_II
LE_221_Maximal_Square
LE_322_Coin_Change
LE_688_Knight_Probability_In_Chessboard                          ***
LE_3040_Maximum_Number_Of_Operations_With_The_Same_Score_II      ***

# Hard (for later)
LE_41_First_Missing_Positive                                         (Array, in-place marker, Circle Sort)  ***
LE_68_Text_Justification
LE_149_Max_Points_On_A_Line                                          (Math)                         ###
LE_218_The_Sky_Line_Problem                                          (PriorityQueue, TreeMap)       ###
LE_233_Number_Of_Digit_One                                           (Math)                         ###
LE_273_Integer_To_English_Words
LE_472_Concatenated_Words                                            (DFS)
LE_768_Max_Chunks_To_Make_Sorted_II                                  (Mono Stack)
LE_909_Snakes_And_Ladders                                            (BFS)                          @@@
LE_996_N_umber_Of_Squareful_Arrays                                   (DFS, Backtracking)
LE_2970_Count_The_Number_Of_Incremovable_Subarrays_I             ###
LE_3030_Find_The_Grid_Of_Region_Average                          not important


# SQL
1148. Article Views I
1174. Immediate Food Delivery II


=================
LE_59_Spiral_Matrix_II                               (Matrix)
LE_121_Best_Time_To_Buy_And_Sell_Stock
LE_122_Best_Time_To_Buy_And_Sell_Stock_II
LE_207_Course_Schedule                               (Topological Sort)
LE_297_Serialize_And_Deserialize_Binary_Tree         (Tree, BFS and DFS)
LE_329_Longest_Increasing_Path_In_A_Matrix           (DFS)
LE_417_Pacific_Atlantic_Water_Flow                   (DFS)
LE_419_Battleships_In_A_Board                        (Matrix)
LE_485_Max_Consecutive_Ones                          (Sliding Window)
LE_487_Max_Consecutive_Ones_II
LE_1004_Max_Consecutive_Ones_III

LE_688_Knight_Probability_In_Chessboard
LE_1249_Minimum_Remove_To_Make_Valid_Parentheses
LE_1207_Unique_Number_Of_Occurrences
LE_300_Longest_Increasing_Subsequence

LE_362_Design_Hit_Counter  (https://leetcode.com/company/apple/discuss/5457845/Apple-and-Coupang-Phone-Screen-Rate-Limiter-or-Hit-Counter)
https://leetcode.com/company/apple/discuss/5531432/Apple-or-Online-or-Ignore-Sections-in-Array
https://leetcode.com/company/apple/discuss/5709113/Tech-Screening-Round
https://leetcode.com/company/apple/discuss/4188668/Apple-240-Problem
https://leetcode.com/company/apple/discuss/2737677/Apple-Syncing-Array-Question
https://leetcode.com/company/apple/discuss/2256688/Battleships-on-Board-or-Apply-Interview-Question

https://leetcode.com/company/apple/discuss/1746870/Apple-or-Phone-or-Basic-sorting:  list.sort(Comparator.comparingInt(o -> (Integer) o.get(1)));

https://leetcode.com/company/apple/discuss/1734481/Apple-top-100-questions

https://leetcode.com/discuss/interview-question/5345416/50-frequently-asked-questions-in-Apple-interview.

LE_387_First_Unique_Character_In_A_String
LE_139_Word_Break
478. Generate Random Point in a Circle   https://leetcode.com/problems/generate-random-point-in-a-circle
LE_390_Elimination_Game
468. Validate IP Address   https://leetcode.com/problems/validate-ip-address
LE_10_Regular_Expression_Matching
https://leetcode.com/problems/course-schedule-iv


求求大家给我点大米我 我点数不够都看不了其他人的面经。。。
1. 现场手搓一个thread pool 然后分析优化
有问一些系统内存相关的问题 followup
2. 给一堆代码做review和优化
基本就是看看细节什么的
3. 不用任何库写一个‍‌‍‍‍‍‌‌‌‍‌‌‍‌‍‌‌‌‌string class 外加iterator function
4. LRU cache
所有的都要求自己写test case 然后跑过。。。


两轮店面一道检查是否huiwen字符串，一道throttle变形
6轮欧尼斯特：
1. 自己做一个linklist能够添加，删除，追踪head，之后一道电梯design口述
2. 一道类似给了不同城市和K Stop你需要用完所有的stop从开始到结束，用BFS 解了
3. 设计自己的redux store, action 之类的需要写code，已经有template了，理解后不难‍‌‍‍‍‍‌‌‌‍‌‌‍‌‍‌‌‌‌
4.类似parse的一道记不太清le
5.记不清了
6.behavior加一道find anagram


大概就是给了一堆startup resources, resources之间有dependencies，比如要启动DB需要hard disk先ready，启动hard disk不用depen on anything
给list of resources和他们的depenencies，返回一个valid的启动顺序
有可能有loop，需要自己detect 并返回error



类似LC300加了一个gap requirement 不能超过一定的数字，应该是用DP做但当时没想起来，更好的的方法是 patience sorting
list of versions (int) of models [1,423,567,2467,8546]
get sub list of models by ver num,
1. ver num strickly increasing
2. diff bwt the adjacent version num meet rules
 2.a diff <= fixed gap number
to find
longest sub list of models meet the crit, for eval work
input = [1,423,567,888, 351, 743, 2467,8546], gap_num= 1000
output = [1, 423, 567]
cand1: 1,423
cand2: 1,423,567
cand3: 423,567,888
cand4: 1, 567, 8546


LE_23_Merge_k_Sorted_Lists
电面是一轮coding 问题是merge k iterator, input是List<Iterator<Integer>> output是Integer 要求按照数字大小merge 打印下一个数字
 比如两个Iterator it1 it2 it1.next() = 2. it2.next() = 3 打印2和3 所以很像利口二三 但是input output变了
因为output一个Integer divide&conquer不适用了 要用解法三 存一个PQ<Iterator>
follow-up问怎么productionize这个算法 我说production的时候这个List<Iterator<Integer>>会存在多个机器上 这样我们需要在每台机器‍‌上存这样
的heap 运行这个算法 每次要找下一个数的时候 再用一台机器去把每个机器里面的heap里的最小值拿出来比较 最后我说就是map reduce的原理
然后面试官又让我讲一下shuffle



最近我朋友面试了 Uber 的 Staff+ sde岗，碰到了一道挺难的系统设计题。题目是设计一个Event Lifecycle Management System（事件生命周期管理系统），系统需要从不同的服务中接收大量消息并进行分析。难点在于，数据量非常大，单一的磁盘或服务器根本装不下，而且事件的顺序可能是乱的（比如 endEvent 先到，而 startEvent 后到），甚至有时候事件会在实际发生几天后才到达系统。
刚开始，题目看起来还挺直观的：
1. startEvent(event_id, timestamp)：记录事件开始，
2. endEvent(event_id, timestamp)：记录事件结束，
3. getOngoingEvents(timestamp)：查询某个时间点的进行中事件。
但是在问了一些澄清问题后，他发现真实的需求其实有点不同。比如，他们特别指出 getOngoingEvents(timestamp) 只能查询 24小时以前的数据。而且，事件最长只持续一个小时。
这个细节其实非常关键，因为它意味着我们不需要支持实时查询！我们有一天的缓冲时间，所以问题变得相对简单了。我们可以用 批处理 来解决问题，而不是实时更新，设计也因此简化了不少。
一开始，他考虑用常见的实时系统解决方案，比如bucketing time series data。但在更深入了解了面试官的真正要求后，他意识到批处理才是更合理的选择。
所以他提出了这样一个方案：
* 先将事件数据接收到一个分布式系统中（比如 Kafka），因为数据量太大，单台服务器无法处理。
* 然后，利用批处理来整理那些乱序到达的事件，并在执行查询前预先聚合数据。
* 因为查询只需要查询至少 24 小时前的数据，所以批处理不需要实时进行，定期运行即可满足需求。
关键的经验是：一开始问题看上去很复杂，因为他以为需要实时解决方案。但在真正理解需求后，发现设计一个高效的批处理系统就够了。所以，千万别忘了在面试时多问问题，搞清楚需求，避免把问题想得太复杂！
我请他把他的答案写在了codemia上，Design an event lifecycle management system , 大家可以看看写的怎么样
Leetcode也讨论过这道题，但是大部‍‌分人都没有弄清requirements是什么:
https://codemia.io/system-design/design-an-event-lifecycle-management-system/submissions/sijcdu

https://leetcode.com/company/apple/discuss/5531432/Apple-or-Online-or-Ignore-Sections-in-Array
https://leetcode.com/company/apple/discuss/5457845/Apple-and-Coupang-Phone-Screen-Rate-Limiter-or-Hit-Counter
*****

面的是个cloud的team，一开镜头是个abc小哥，问想先介绍组还是做题，无脑先做题，考是的job scheduler，给了两个function
add_task(job, priority, Set dependency)
run_task()
第一个是可以添加一个job A，每个job有Int prioity（小的job有high priority），dependency是一个set，如果要run task A之前必须保证他的
dependency都在他之前run，第二个function就是return一个valid的所有job的scheduler。第一个问题问怎么解决dependency，
答用一个topological sorting，再对每个job的dependency按照priority排序，小哥觉得ok。第二个followup是怎么解决priority的，
比如add_task(a, 0, [b,c]), add_task(e, 1, [f, g])，答用一个min heap保存所有job的（job， priory）pair，创建一个这样的data structure，
比如第一个[(b, p_b), (c, p_c), (a,0)], 第二个[(f,p_f), (g, p_g), (e,1)]，这样heap就有两个，key为每个element的第0个index，
就能做到按照priority排序。第三个followup是怎么解决不同job之间有dependency，我说的是可以创建一个neighbor count的map存有多少dependency（每次pop的时候给上面list最末尾的-1 index decrement），
再用一个middle list去存那些pop出来inde 0的neighbor count不是0的list，直到pop出是0的（同时再保存一个visited的set防止repeat），
最后再把所有middle list的pop进heap里，思路应该是正确的，看小哥表情是有些疑惑，但是因为没见过这道题也没想到更好的解法，
最后让我simulate了下算法，说了个visible就完了。时间也到了，也没有聊更多。

感觉有点无语，出题前给我说了算法题会非常easy（个人并不觉得，可能我太菜了。。），而且题更偏system方面也练得很少，能把思路非常清楚得讲出来更重要吧。


hm直接面试第一轮，问我有没有做过hadoop或者是map reduce，我说没有，我主要做kafka和flink相关的。于是hm口述了下map reduce的工作原理，说你做没做过不重要，这是cs fundamental。 面试的组是一个T1 team，负责apple media service 相关的big data platfrom（比如itune，apple tv...），组里主要管5个data pipeline，计划要再expand 1-2条。
题目场景：需要处理很多file，总共1 TB
each file 128GB
所以有8000 files ，目前存在HDFS里，想要把这1 TB data放入map reduce处理。
mapper的数量就是file split的数量，也就是8000 map(),
map()的数量，是reduce()的4倍。(我不懂为什么，就是给我的条件)，所以2000 reduce().
map ()： 主要就是把data拆成key value pair，比如 “i am a student”, 拆成
i， 1
am， 1
a， 1
student， 1
reduce():还有两个步骤，
1. shuffle - 保证同样的key，一定会留到同样的partition；
2. sort & merge- 把同样的key的value merge起来， 使用merge sort算法
根据这个，他问了我几个问题：
1. 怎么保证shuffle时候，同样的key一定会流到同样的partition?
答案是在key value那里，加salt （我没有完全懂）
2. 为什么会出现reduce() job会非常非常长的时间，还没有做好？
前提是，map()一定需要全部做完‍‌，才能开始reduce()。并且一些reduce()已经做完了
答案是，因为reduce()是用water count （也就是count one by one for each key)， 所以如果key非常多，salt加的不好， sort & merge就会花费很久 （我没有完全懂）

In the shuffle phase of MapReduce, the partitioner is responsible for assigning keys to partitions. The partitioner
typically uses the hash of the key (e.g., hash(key) % numPartitions) to ensure that all values with the same key are sent
to the same partition. This guarantees that the reducer processing the partition will receive all values associated with
a particular key.

Why some reduce jobs may take a long time:
Skewed Data: If the distribution of keys is uneven, some reducers may receive significantly more data, causing data skew.
Stragglers: Some reducers may process more complex or larger datasets, causing them to take longer (often referred to as straggler tasks).
I/O Bottleneck: Disk I/O, network latency during shuffling, or heavy reads/writes can slow down reduce tasks.
Resource Contention: Limited CPU or memory resources may slow down specific reduce tasks when multiple jobs compete for the same resources.

Adding salt to the key in MapReduce involves appending or prepending a random or calculated value (the salt) to the key
during the mapping phase. This is done to reduce data skew when certain keys are disproportionately frequent.

Why Use Salt?
In cases where many records share the same key, these keys will all be sent to the same reducer, leading to a potential
bottleneck. By adding a salt (like a random number or hash), the keys are distributed across multiple partitions,
thus balancing the load among reducers.

Example:
Original key: user_id
Salted key: salt + user_id (e.g., random(0-9)_user_id)
This spreads the same key across different reducers and reduces bottlenecks.

In MapReduce, a combiner function is an optional, mini-reducer that runs on the map node before the data is shuffled to
the reducers. Its purpose is to perform a local reduction on the mapper output to minimize the amount of data transferred
across the network. The combiner reduces data volume by merging or aggregating intermediate key-value pairs that share
the same key, similar to what a reducer does, but on a smaller, localized scale. This improves efficiency by reducing
traffic and speeding up the overall job execution.




Review
LE_146_LRU_Cache
LE_153_Find_Min_In_Rotated_Sorted_Array
LE_207_Course_Schedule
LE_253_Meeting_Rooms_II
LE_688_Knight_Probability_In_Chessboard   (DP)
LE_274_H_Index
LE_325_Maximum_Size_Subarray_Sum_Equals_k
LE_437_Path_Sum_III
LE_953_Verifying_An_Alien_Dictionary
LE_2970_Count_The_Number_Of_Incremovable_Subarrays_I      *****
LE_565_Array_Nesting
LE_986_Interval_List_Intersections

LE_1074_Number_Of_Submatrices_That_Sum_To_Target          (hard)

LE_2348_Number_Of_Zero_Filled_Subarrays

Find_Cycle
LE_261_Graph_Valid_Tree                                  Detect cycle in undirected graph  *****

## Merge K sorted list/stream
Merge_K_Sorted_Stream
LI_577_Merge_K_Sorted_Interval_Lists

LE_297_Serialize_And_Deserialize_Binary_Tree              *****
LE_428_Serialize_And_Deserialize_Nary_Tree                *****

LE_281_Zigzag_Iterator
LI_541_Zigzag_Iterator_II

LE_894_All_Possible_Full_Binary_Trees
LE_1060_Missing_Element_In_Sorted_Array                   Binary Search  *****
LE_212_Word_Search_II                                     Trie

2024-09-24 Plan:
1.Go over the LE problems shown in mianjing
2.Java Concurrency (book and LE/interview problems)
3.System Design
#DP
LE_256_Paint_House (***)
LE_265_Paint_House_II  (followup)
LE_730_Count_Different_Palindromic_Subsequences              revisit
LE_40_Combination_SUM_II
LE_377_Combination_Sum_IV   (Actually it is permutation sum and unbounded)  (*****)
LE_322_Coin_Change          (***)
LE_518_Coin_Change_II       (***)
LE_198_House_Robber
LE_213_House_Robber_II
LE_337_House_Robber_III
LE_746_Min_Cost_Climbing_Stairs     (***)
LE_516_Longest_Palindromic_Subsequence
LE_115_Distinct_Subsequences
LE_62_Unique_Path
LE_64_Min_Path_Sum
LE_05_Longest_Palindromic_Substring
LE_730_Count_Different_Palindromic_Subsequences
Max_Subsequence_Skip_One
Min_Difference_Sum_In_Two_Arrays

#Min-Max Strategy (Gaming Theory), Recursion + Memoization
LE_464_Can_I_Win
LE_486_Predict_The_Winner

#Knapsack
LI_563_Backpack_V

#Data Structure Design
LE_244_Shortest_Word_Distance_II
LE_895_Maximum_Frequency_Stack
LE_981_Time_Based_Key_Value_Store
LE_352_Data_Stream_As_Disjoint_Intervals  (***)              revisit
LE_716_Max_Stack
LE_380_Insert_Delete_GetRandom_O1
LE_381_Insert_Delete_GetRandom_O1_Duplicates_Allowed
(multi-thread, 问基础知识，然后lock该加在哪一行)
LE_432_All_O_One_Data_Structure           (*****)
LE_359_Logger_Rate_Limiter
LI_215_Rate_Limiter                       (***)
CustomizedHashMap
Delayed_Scheduler
Retain_Best_Cache
Merge_Intervals                           (*****)            revisit
Max_Stack

#Array and String
LE_20_Valid_Parentheses
LE_384_Shuffle_An_Array
LE_41_First_Missing_Positive              (******)!!!
LE_277_Find_The_Celebrity
LE_243_Shortest_Word_Distance
LE_245_Shortest_Word_Distance_III
Word_Distance_IV
LE_611_Valid_Triangle_Number
LE_42_Trapping_Rain_Water
LE_08_String_To_Integer
LE_65_Valid_Number
LI_587_Two_Sum_Unique_Pairs
LE_170_Two_Sum_III_Data_Structure_Design
input和sum两种最优都要写。分别是预处理所有的sum以及简单hashmap，每次求是否有sum再on走一遍
LE_53_Maximum_Subarray
LE_152_Maximum_Product_Subarray
LE_318_Maximum_Product_Of_Word_Lengths
LE_628_Maximum_Product_Of_Three_Numbers
LE_239_Sliding_Window_Maximum                (***)
LE_68_Text_Justification                     (*****)
LE_08_String_To_Integer
LE_567_Permutation_In_String
LE_358_Rearrange_String_K_Distance_Apart
LE_30_SubstrConactWords                      (Sliding Window)
LE_151_Reverse_Words_In_A_String
LE_215_Kth_Largest_Element_In_Array
LI_005_Kth_Largest_Number
LE_605_Can_Place_Flowers
LE_722_Remove_Comments

LE_387_First_Unique_Character_In_A_String
此后他不会出现，但是会对time space优化考察
(LI_209_First_Unique_Character_In_A_String
 LI_685_First_Unique_Number_In_Stream
)
LE_187_Repeated_DNA_Sequences
#Prefix Sum
LE_548_Split_Array_With_Equal_Sum            (*****)


#Graph
LE_261_Graph_Valid_Tree        followup 改成判断存不存在环
LE_366_Find_Leaves_Of_Binary_Tree
(binary tree leaves的变种把bt变成了graph，没什么太大区别，注意一下recursion时候返回条件就好了)
LE_133_Clone_Graph

#Tree and BST
LE_235_Lowest_Common_Ancestor_Of_BST
LE_236_Lowest_Common_Ancestor_Of_BT
follow up是如果有parent pointer怎么做，constant space : LE_160_Intersection_Of_Tow_Linked_List
LE_156_Binary_Tree_Upside_Down
LE_310_Minimum_Height_Trees     (??)
LI_596_Minimum_Subtree
LE_111_Min_Depth_Of_Binary_Tree
LE_426_Convert_Binary_Search_Tree_To_Sorted_Doubly_Linked_List
LE_272_Closest_BST_Value_II                                     (*****)
LE_297_Serialize_And_Deserialize_Binary_Tree
LE_314_Binary_Tree_Vertical_Order_Traversal
LE_366_Find_Leaves_Of_Binary_Tree                               (*****)

#PriorityQueue
#K-way
LE_23_Merge_k_Sorted_Lists     (*** followups)
LI_486_Merge_K_Sorted_Arrays
LE_373_Find_K_Pairs_With_Smallest_Sums

#Search DFS/BFS
LE_282_Expression_Add_Operators
LE_254_Factor_Combinations
LE_47_Permutation_II
LE_721_Accounts_Merge                             (*****)
LE_698_Partition_To_K_Equal_Sum_Subsets
LE_79_Word_Search
LE_212_Word_Search_II    (Trie or HashMap + DFS)
LE_282_Expression_Add_Operators
Multi_Dimension_Array_Sum

#Stack
LE_150_Evaluate_Reverse_Polish_Notation
LE_282_Expression_Add_Operators
LE_636_Exclusive_Time_Of_Functions

LE_339_Nested_List_Weight_Sum
LE_364_Nested_List_Weight_Sum_II
LE_341_Flatten_Nested_List_Iterator (***)
follow up 比较多， 首先写了个preprocessing using dfs， 就是recursion的写法。后来要求优化成iterative的形式;
再后来，讨论了下极端情况， 也就是tree不balance， 方法就是push到stack之前不做flattening， 记下一个index。当时脑子比较懵，
没写完，刚刚写了一下post到了里的口德里。
https://leetcode.com/problems/fl ... flattening-the-list

#Geometry
LE_149_Max_Points_On_A_Line
LE_973_K_Closest_Points_To_Origin
K_Closest_Points_To_A_Given_Point

#LinkedList
LE_142_Linked_List_Cycle_II

#k-way merge
LE_23_Merge_k_Sorted_Lists
LI_486_Merge_K_Sorted_Arrays
LE_373_Find_K_Pairs_With_Smallest_Sums (smallest product, without sort)   (***)
Intersection_Union_Of_K_Sorted_Lists

#Binary Search
LE_633_Sum_Of_Square_Numbers
Kth_Missing_Element_In_Sorted_Array

#Matrix
LE_311_Sparse_Matrix_Multiplication
LI_654_Sparse_Matrix_Multiplication
LE_200_Number_Of_Islands
LE_694_Number_Of_Distinct_Islands
LE_695_Max_Area_Of_Island

#Union Find
Find_Same_Person

#Topological Sort
Merge_Properties

Generic_Permutation                               (***)
H2O
Hopping_Iterator
Max_Subsequence_Skip_One


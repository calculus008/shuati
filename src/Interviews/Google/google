Minimize the largest sum among these M groups :
LE_410_Split_Array_Largest_Sum

不同的马甲
LE_1014_Capacity_To_Ship_Packages_Within_D_Days
1. 一片巧克力数组分成K块，数字代表甜度，第一个人会想拿最甜的一块，把他平分成一个状态使得第一个人拿到的总甜度是最小的，
   求第一人拿到的甜度

2. 一个必须依照数组顺序完成的工作，数字代表工作难易度，分成K天完工，尽可能把困难度最高的一天变得比较不累，求最累的一天的困难度
   LE_875_Koko_Eating_Bananas

3. 一个数组代表一排的书，数字代表页数，现在必须把相邻的书分成K组放置到K台打印机，设置一个配置方法使得需要打印最多页数的机器打印最少页，
   求工作量最多的打印机需要打印的页数
   LI_437_Copy_Books
   LI_438_Copy_Books_II

4. 一个包裹数组，数字代表重量，依包裹排列顺序分成K批寄送，使得最重的一批重量最小，求最重一批重量（利口比赛刚出的）

Variations :
LE_774_Minimize_Max_Distance_To_Gas_Station

Max of the minimum among M groups :
Chocolate_Sweetness

================================

BicyblePeopleMatching
Redundant_Connection_BST

LE_128_Longest_Consecutive_Sequence
LE_684_Redundant_Connection
LE_685_Redundant_Connection_II

LE_62_Unique_Path
LE_63_Unique_Path_II
LE_64_Min_Path_Sum

1055. Shortest Way to Form String  (***)


================================

矩阵里面有0，1，2，3

0表示可以通过
3表示障碍物不能穿行。

现在需要你找离1最短的2.

Example :
323003
130001  <- 最左边的1是离右下角的2最短距离的。
000333
330002

#我觉得是把所有的1同时放进队列里，然后按层遍历，第一个遇到的2就是最短的2.


#对于每一个1进行bfs，会产生一个距离场，场里每个点的value就是这个点到场中心1的距离。
所有的1对应的距离场叠加（累积），场值最小的2的位置就是解。(这应该是求到所有1距离和最小的2）
具体的话:
LE_317_Shortest_Distance_From_All_Buildings


package leetcode;

import java.util.*;
import java.util.stream.*;

public class LE_924_Minimize_Malware_Spread {
    /**
     * You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.
     *
     * Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.
     *
     * Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.
     *
     * Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
     *
     * Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.
     *
     * Example 1:
     * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
     * Output: 0
     *
     * Example 2:
     * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
     * Output: 0
     *
     * Example 3:
     * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
     * Output: 1
     *
     * Constraints:
     * n == graph.length
     * n == graph[i].length
     * 2 <= n <= 300
     * graph[i][j] is 0 or 1.
     * graph[i][j] == graph[j][i]
     * graph[i][i] == 1
     * 1 <= initial.length <= n
     * 0 <= initial[i] <= n - 1
     * All the integers in initial are unique.
     *
     * Hard
     *
     * https://leetcode.com/problems/minimize-malware-spread/
     */

    /**
     * https://leetcode.com/problems/minimize-malware-spread/discuss/181186/python-dfs-solution-with-picture-to-explain-my-thought(with-extra-Chinese-explanation)
     *
     * Key Points:
     * 1.在一个图中，有某些节点初始处于被感染状态，随着时间的流逝最终会将所有直接或间接与该节点相连的节点全部感染。
     *   现在可以修复一个初始感染节点，我们想使最终的感染节点数量最小，问该修复哪一个初始感染节点。
     * 2.我们很容易发现，如果在一个连通子图里面，有两个或两个以上的节点初始被感染，那么无论我们删除哪个都对最后结果没有影响。
     *   我们唯一能使感染节点减少的操作就是删除那些只有一个感染节点的连通子图中的感染节点。
     * 3.算法：
     *   a.找到一个连通子图 (by iterating each node)
     *   b.判断子图中感染节点的数量，若为1，执行第三步；反之执行第一步
     *   c.计算该子图的长度，长度越长，就越可以最小化感染节点的数量
     *
     *   For step "找到一个连通子图", we can use DFS or Union Find.
     *
     *   Time : O(N ^ 2), where N is the length of graph, as the graph is given in adjacent matrix form.
     *          Each edge (to each neighbor) is considered. So in the worst case in a fully connected graph with O(N^2) edges,
     *          where N is the number of vertices, the runtime is O(N^2)
     *   Space : O(N)
     */
    class Solution_DFS_1 {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            Set<Integer> visited = new HashSet<>();

            int maxInfectedCount = 0;
            int res = Arrays.stream(initial).min().getAsInt();

            /**
             * Iterate every node
             */
            for (int i = 0; i < graph.length; i++) {
                if (visited.contains(i)) continue;

                Set<Integer> set = new HashSet<>();
                set.add(i); //!!!
                dfs(graph, i, set);

                int countMals = 0;
                int minNode = Integer.MAX_VALUE;
                for (int m : initial) {
                    if (set.contains(m)) {
                        countMals++;
                        if (m < minNode) {
                            minNode = m;
                        }
                    }
                }

                if (countMals == 1) {
                    int count = set.size();
                    if (count > maxInfectedCount || (count == maxInfectedCount && i < res)) {
                        maxInfectedCount = count;
                        res = minNode;
                    }
                }

                visited.addAll(set);
            }

            return res;
        }

        /**
         * DFS : starting with a node, find连通子图.
         */
        public void dfs(int[][] graph, int cur, Set<Integer> set) {
            for (int i = 0; i < graph[cur].length; i++) {
                if (cur != i && graph[cur][i] == 1 && !set.contains(i)) {
                    set.add(i);
                    dfs(graph, i, set);
                }
            }
        }
    }

    class Solution_DFS_2 {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            Set<Integer> mals = Arrays.stream(initial).boxed().collect(Collectors.toSet());
            Set<Integer> visited = new HashSet<>();

            int maxInfectedCount = 0;
            int res = Arrays.stream(initial).min().getAsInt();

            /**
             * Iterate nodes in initial
             */
            for (int i : mals) {
                if (visited.contains(i)) continue;

                Set<Integer> set = new HashSet<>();
                set.add(i);
                dfs(graph, i, set);

                boolean oneMal = true;
                for (int num : set) {
                    /**
                     * set contains more than one mal
                     */
                    if (num != i && mals.contains(num)) {
                        oneMal = false;
                        break;
                    }
                }

                if (oneMal) {
                    int count = set.size();
                    if (count > maxInfectedCount || (count == maxInfectedCount && i < res)) {
                        maxInfectedCount = count;
                        /**
                         * !!!
                         */
                        res = i;
                    }
                }

                /**
                 * !!!
                 */
                visited.addAll(set);
            }

            return res;
        }

        public void dfs(int[][] graph, int cur, Set<Integer> set) {
            for (int i = 0; i < graph[cur].length; i++) {
                if (cur != i && graph[cur][i] == 1 && !set.contains(i)) {
                    set.add(i);
                    dfs(graph, i, set);
                }
            }
        }
    }

    /**
     * Union Find
     *
     * Union found all nodes.
     * Count the union size of each union set.
     * Count the malware number of each union set.
     *
     * Return the biggest union's malware if there is one and only one malware.
     * If no such union that has and has only one malware, return the malware with minimum index.
     */
    class Solution_Uion_Find {
        private int[] p;

        public int minMalwareSpread(int[][] g, int[] initial) {
            int n = g.length;
            p = new int[n];

            for (int i = 0; i < n; i++) {
                p[i] = i;
            }

            for (int i = 0; i < n; i++) {
                for (int j = i + 1; j < n; j++) {
                    if (g[i][j] == 1) {
                        union(i, j);
                    }
                }
            }

            int[] ufSize = new int[n];
            int[] malCount = new int[n];

            for (int i = 0; i < n; i++) {
                ufSize[find(i)]++;
            }

            for (int init : initial) {
                malCount[find(init)]++;
            }

            // for maximum ufSize, if malware count is 1, return that index
            int res = -1;
            int maxSize = 0;
            Arrays.sort(initial);

            for (int init : initial) {
                int idx = find(init);
                if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                    maxSize = ufSize[idx];
                    res = init;
                }
            }
            if (maxSize != 0) {
                return res;
            }

            return initial[0];
        }

        private void union(int i, int j) {
            p[find(i)] = find(j);
        }

        private int find(int i) {
            if (p[i] == i) {
                return i;
            } else {
                p[i] = find(p[i]);
                return p[i];
            }
        }
    }
}
